Digit recognizer

The goal in this competition is to take an image of a handwritten single digit, and determine what that digit is.
The data for this competition were taken from the MNIST dataset. The MNIST 
("Modified National Institute of Standards and Technology") dataset is a classic within the Machine Learning community
that has been extensively studied.

The data files train.csv and test.csv contain gray-scale images of hand-drawn digits, from zero through nine.

Each image is 28 pixels in height and 28 pixels in width, for a total of 784 pixels in total. Each pixel has
a single pixel-value associated with it, indicating the lightness or darkness of that pixel, with higher numbers
meaning darker. This pixel-value is an integer between 0 and 255, inclusive.

Each pixel column in the training set has a name like pixelx, where x is an integer between 0 and 783, inclusive.
To locate this pixel on the image, suppose that we have decomposed x as x = i * 28 + j, where i and j are integers between 0 and 27,
inclusive. Then pixelx is located on row i and column j of a 28 x 28 matrix, (indexing by zero).

As the data is huge and it is impossible to model an algorithm on the this amount of data. Therefore, Dimension reduction is must.
So as to reduce the data without loosing huge amount of information the best is to apply PCA.

After Applying PCA and Plotting variance explained Vs Number of Variance Explained. Almost 45 principal Components explained 99% of variance 
present in the training data.

[!alt tag](https://github.com/thefiercedemon/kaggle-/blob/master/digit%20recognizer/Variance%20Explained.png)

After PCA which reduced the dimension of the data , Now SVM(Support Vector Machines) can be applied easily using e1071 package in R.
The support vector algorithm gives a high accuracy and PCA complements the SVM to increase accuracy.

Deep Dive in the Data! :)
